`timescale 1ns / 1ps
module CPU(clk,q,t,smg,aa,bb);
input clk;
input [2:0]t;
output [31:0]smg;
output [31:0]aa;
output [31:0]bb;
output [15:0]q;
wire [31:0]pc,aaa,bbb;
wire[31:0] pcIn,pc1,b_address,pc2,j_address;
wire[25:0]jump_address;
wire[31:0]address_or_in,result3;
wire [31:0]ins,result2;
wire [5:0]opcode;
wire [5:0]funct;
wire [3:0]ALU_control;
wire [4:0]Reg1,Reg2,Reg3;
wire [31:0]Write_data,Write_data2;
wire [31:0]readreg_data1,readreg_data2;
wire [4:0]Write_Reg;
wire RegDst,Branch,MemRead,MemtoReg,MemWrite,ALUsrc,RegWrite;
wire [1:0]ALUOp;
wire zero,zero2,zero3,EXMEM_MemWrite,EXMEM_MemtoReg;
wire [31:0]a,b,result1;
wire [31:0]result,writedata;
wire ifbranch,Jump;
wire [31:0]readmemory;
wire [31:0]ra;
wire [5:0]shamt;
reg clk_temp;
wire [31:0]ifid_pc,ifid_pcIn,ifid_ins;
wire [4:0]ifid_rs,ifid_rt,ifid_rd;
wire IDEX_RegDst,IDEX_ALUsrc,IDEX_RegWrite,IDEX_MemWrite;
wire [15:0]IDEX_imm;
wire [4:0]IDEX_WriteReg;
wire [31:0]IDEX_data1,IDEX_data2;
wire IDEX_MemtoReg,IDEX_Branch;
wire [31:0]IDEX_ins;
wire [1:0]IDEX_ALUOp;
wire [31:0]reading_data1,reading_data2;
wire [31:0]IDEX_pc,EXMEM_pc,MEMWB_pc;
wire [31:0]EXMEM_result,MEMWB_result;
wire [4:0]EXMEM_writereg,MEMWB_writereg;
wire EXMEM_regwrite,MEMWB_regwrite;
wire EXMEM_RegDst,MEMWB_RegDst;
wire jump1,jump2,jump3;
wire [31:0]ins_1,pc_2,pc_3;
wire [4:0]w1,w2,w3,wr1,wr2,wr3;
assign q[15:8]=MEMWB_pc[7:0];
assign q[7:0]=MEMWB_result[7:0];
assign opcode=ifid_ins[31:26];
assign funct=ifid_ins[5:0];
assign jump_address=ifid_ins[25:0];
assign address_or_in[15:0]=ifid_ins[15:0];
assign address_or_in[31:16]={16{ifid_ins[15]}};
assign Reg1=ifid_ins[25:21];
assign Reg2=ifid_ins[20:16];
assign Reg3=ifid_ins[15:11];
//assign Write_Reg=ifid_ins[20:16];
assign b_address=address_or_in*4+ifid_pcIn;
assign zero=reading_data1 == reading_data2;
assign ifbranch=zero3 & Branch;
assign j_address[27:0]=(opcode==6'b000000&&funct==6'b001000)? ra[27:0]:(jump_address*4);
assign j_address[31:28]=(opcode==6'b000000&&funct==6'b001000)?ra[31:28]:ifid_pcIn[31:28];
assign a=IDEX_data1;
assign shamt=IDEX_imm[10:6];
assign zero2=~zero;
assign aa=pc;
assign bb=ins;
assign result2=(jump1||ins_1[31:26]==6'b000000&&ins_1[5:0]==6'b001000)?32'b0:result;
//Adder#(32) add1({{14{ifid_ins[15]}},ifid_ins[15:0],2'b00},pcIn,b_address);
Mulx#(32)m1(b_address,pcIn,ifbranch,pc1);
Mulx#(32)m2(j_address,pc1,Jump||(opcode==6'b000000&&funct==6'b001000),pc2);
PC p1(clk,pc2,pc);
PCAdder4 p2(pc,pcIn);
IFID_Registers ifid(clk,pc,pcIn,ins,ifid_pc,ifid_pcIn,ifid_ins,ifid_rs,ifid_rt,ifid_rd);
InsMem uInsMem(pc,ins);
Control c1(opcode,RegDst,Jump,Branch,MemRead,MemtoReg,ALUOp,MemWrite,ALUsrc,RegWrite);
ALUControl a1(IDEX_ins[5:0],IDEX_ALUOp,ALU_control);
Mulx#(5)m3(Reg3,Reg2,RegDst,Write_Reg);////0选rt写入，1选rd写入
Registers r1(ifid_rs,ifid_rt,clk,MEMWB_regwrite,MEMWB_writereg,MEMWB_result,reading_data1,reading_data2,ifid_rd,MEMWB_RegDst,opcode,ra,pcIn);
IDEX_Registers idex(clk,ifid_pc,ifid_ins,ALUOp,RegDst,ALUsrc,RegWrite,MemtoReg,MemWrite,ifid_ins[15:0],Jump,Write_Reg,ins_1,IDEX_pc,reading_data1,reading_data2,IDEX_RegDst,IDEX_ALUsrc,IDEX_RegWrite,IDEX_MemtoReg,IDEX_MemWrite,IDEX_imm,IDEX_data1,IDEX_data2,IDEX_ins,IDEX_ALUOp,jump1,wr1);
Mulx#(32)m4({{16{IDEX_imm[15]}},IDEX_imm},IDEX_data2,IDEX_ALUsrc,b);//ALUsrc0选寄存器，1选立即数或是地址
ALU al1(a,b,ALU_control,IDEX_ins[5:0],IDEX_ins[31:26],result,shamt);
Mulx#(1)m8(zero,zero2,ifid_ins[31:26]==6'b000100,zero3);
//Mulx#(32)m9(32'b0,result,jump1||ins_1[31:26]==6'b000000&&ins_1[5:0]==6'b001000,result2);
EXMEM_Registers ex1(clk,result3,IDEX_data2,IDEX_pc,result2,IDEX_RegDst,IDEX_RegWrite,IDEX_MemWrite,wr1,IDEX_MemtoReg,EXMEM_pc,EXMEM_result,EXMEM_RegDst,EXMEM_regwrite,EXMEM_MemWrite,wr2,EXMEM_MemtoReg,aaa);
DataMem d1(EXMEM_result,clk,aaa,EXMEM_MemWrite,readmemory,t,smg);
Mulx#(32)m5(readmemory,EXMEM_result,EXMEM_MemtoReg,Write_data);//MemtoReg1返回数据存储器内容,0返回ALU结果
//Mulx#(32)m6(32'b0,Write_data,Jump||(opcode==6'b000000&&funct==6'b001000),Write_data2);
MEMWB_Registers mem1(clk,EXMEM_pc,Write_data,EXMEM_RegDst,EXMEM_regwrite,wr2,MEMWB_pc,MEMWB_result,MEMWB_RegDst,MEMWB_regwrite,MEMWB_writereg);
endmodule



